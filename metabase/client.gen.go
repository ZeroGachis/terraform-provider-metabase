// Package metabase provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package metabase

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	SessionScopes = "Session.Scopes"
)

// Defines values for DatabaseDetailsBigQueryDatasetFiltersType.
const (
	All       DatabaseDetailsBigQueryDatasetFiltersType = "all"
	Exclusion DatabaseDetailsBigQueryDatasetFiltersType = "exclusion"
	Inclusion DatabaseDetailsBigQueryDatasetFiltersType = "inclusion"
)

// Defines values for DatabaseEngine.
const (
	BigqueryCloudSdk DatabaseEngine = "bigquery-cloud-sdk"
)

// Collection A collection that regroups dashboards and cards.
type Collection struct {
	// Archived Whether the collection is archived.
	// When archived, a collection no longer appears in the list publicly.
	Archived *bool `json:"archived,omitempty"`

	// Color A color for the collection.
	Color *string `json:"color,omitempty"`

	// Description A description for the collection.
	Description *string `json:"description"`

	// EntityId A unique string identifier for the collection.
	EntityId *string `json:"entity_id,omitempty"`

	// Id The unique ID for the collection.
	// Created collections will have an integer ID. The automatically-created root collection's ID is `root`.
	Id Collection_Id `json:"id"`

	// Location A path-like location, useful when this is a sub-collection.
	Location *string `json:"location,omitempty"`

	// Name The name of the collection.
	Name string `json:"name"`

	// ParentId The ID of the parent collection, if any.
	ParentId *int `json:"parent_id"`

	// PersonalOwnerId The ID of the user owning this collection, if it is a personal collection.
	PersonalOwnerId *int `json:"personal_owner_id"`

	// Slug The slug for the collection, used in URLs.
	Slug *string `json:"slug,omitempty"`
}

// CollectionId0 defines model for .
type CollectionId0 = string

// CollectionId1 defines model for .
type CollectionId1 = int

// Collection_Id The unique ID for the collection.
// Created collections will have an integer ID. The automatically-created root collection's ID is `root`.
type Collection_Id struct {
	union json.RawMessage
}

// CreateCollectionBody The payload used to create a new collection.
type CreateCollectionBody struct {
	// Color A color for the collection.
	Color string `json:"color"`

	// Description A description for the collection.
	Description *string `json:"description"`

	// Name The name of the collection.
	Name string `json:"name"`

	// ParentId The ID of the parent collection, if any.
	ParentId *int `json:"parent_id"`
}

// CreateDatabaseBody The payload used to create a new database.
type CreateDatabaseBody struct {
	// Details The content of the `details` map for a database when connecting to BigQuery.
	Details DatabaseDetailsBigQuery `json:"details"`

	// Engine The type of database to connect to.
	Engine DatabaseEngine `json:"engine"`

	// Name The user-displayable name for the database.
	Name string `json:"name"`
}

// CreatePermissionsGroupBody The payload used to create a new permissions group.
type CreatePermissionsGroupBody struct {
	// Name A user-displayable name for the group.
	Name string `json:"name"`
}

// CreateSessionBody The credentials required to create a session.
type CreateSessionBody struct {
	// Password The password for the account.
	Password string `json:"password"`

	// Username The name of the user, or his email.
	Username string `json:"username"`
}

// Database An external database that can be queried by cards and dashboards.
type Database struct {
	// Details The content of the `details` map for a database when connecting to BigQuery.
	Details DatabaseDetailsBigQuery `json:"details"`

	// Engine The type of database to connect to.
	Engine DatabaseEngine `json:"engine"`

	// Id The ID for the database.
	Id int `json:"id"`

	// Name The user-displayable name for the database.
	Name string `json:"name"`
}

// DatabaseDetailsBigQuery The content of the `details` map for a database when connecting to BigQuery.
type DatabaseDetailsBigQuery struct {
	// DatasetFiltersPatterns The pattern used by the `dataset-filters-type`.
	DatasetFiltersPatterns *string `json:"dataset-filters-patterns,omitempty"`

	// DatasetFiltersType The behavior of how BigQuery datasets should be selected.
	DatasetFiltersType *DatabaseDetailsBigQueryDatasetFiltersType `json:"dataset-filters-type,omitempty"`

	// ProjectId The ID of the GCP project containing the BigQuery datasets.
	ProjectId *string `json:"project-id,omitempty"`

	// ServiceAccountJson The content of the service account key file.
	ServiceAccountJson string `json:"service-account-json"`
}

// DatabaseDetailsBigQueryDatasetFiltersType The behavior of how BigQuery datasets should be selected.
type DatabaseDetailsBigQueryDatasetFiltersType string

// DatabaseEngine The type of database to connect to.
type DatabaseEngine string

// Field A field in a database.
type Field struct {
	// Id The ID of the field.
	Id int `json:"id"`

	// Name The name of the field (column) in the table.
	Name string `json:"name"`
}

// PermissionsGroup A group of users to which permissions can be granted.
type PermissionsGroup struct {
	// Id The ID of the permissions group.
	Id int `json:"id"`

	// Name A user-displayable name for the group.
	Name string `json:"name"`
}

// Session A session that can be used to perform authenticated requests to the API.
type Session struct {
	Id string `json:"id"`
}

// Table A table in a database.
type Table struct {
	// DbId The ID of the parent database.
	DbId int `json:"db_id"`

	// DisplayName The name displayed in the interface for the table.
	DisplayName *string `json:"display_name,omitempty"`

	// EntityType The type of table.
	EntityType string `json:"entity_type"`

	// Id The ID of the table.
	Id int `json:"id"`

	// Name The name of the table.
	Name string `json:"name"`

	// Schema The database schema in which the table is located.
	// For BigQuery, this is the dataset name.
	Schema *string `json:"schema"`
}

// TableMetadata defines model for TableMetadata.
type TableMetadata struct {
	// DbId The ID of the parent database.
	DbId int `json:"db_id"`

	// DisplayName The name displayed in the interface for the table.
	DisplayName *string `json:"display_name,omitempty"`

	// EntityType The type of table.
	EntityType string `json:"entity_type"`

	// Fields The list of fields in the table.
	Fields []Field `json:"fields"`

	// Id The ID of the table.
	Id int `json:"id"`

	// Name The name of the table.
	Name string `json:"name"`

	// Schema The database schema in which the table is located.
	// For BigQuery, this is the dataset name.
	Schema *string `json:"schema"`
}

// UpdateCollectionBody The payload used to update an existing collection.
type UpdateCollectionBody struct {
	// Archived Whether the collection is archived.
	// When archived, a collection no longer appears in the list publicly.
	Archived *bool `json:"archived,omitempty"`

	// Color A color for the collection.
	Color *string `json:"color,omitempty"`

	// Description A description for the collection.
	Description *string `json:"description"`

	// Name The name of the collection.
	Name *string `json:"name,omitempty"`

	// ParentId The ID of the parent collection, if any.
	ParentId *int `json:"parent_id"`
}

// UpdateDatabaseBody The payload used to update an existing database.
type UpdateDatabaseBody struct {
	// Details The content of the `details` map for a database when connecting to BigQuery.
	Details *DatabaseDetailsBigQuery `json:"details,omitempty"`

	// Engine The type of database to connect to.
	Engine *DatabaseEngine `json:"engine,omitempty"`

	// Name The user-displayable name for the database.
	Name *string `json:"name,omitempty"`
}

// UpdatePermissionsGroupBody The payload used to update an existing permissions group.
type UpdatePermissionsGroupBody struct {
	// Name A user-displayable name for the group.
	Name string `json:"name"`
}

// GetTableMetadataParams defines parameters for GetTableMetadata.
type GetTableMetadataParams struct {
	// IncludeHiddenFields Whether the query should return hidden fields.
	IncludeHiddenFields *bool `form:"include_hidden_fields,omitempty" json:"include_hidden_fields,omitempty"`
}

// CreateCollectionJSONRequestBody defines body for CreateCollection for application/json ContentType.
type CreateCollectionJSONRequestBody = CreateCollectionBody

// UpdateCollectionJSONRequestBody defines body for UpdateCollection for application/json ContentType.
type UpdateCollectionJSONRequestBody = UpdateCollectionBody

// CreateDatabaseJSONRequestBody defines body for CreateDatabase for application/json ContentType.
type CreateDatabaseJSONRequestBody = CreateDatabaseBody

// UpdateDatabaseJSONRequestBody defines body for UpdateDatabase for application/json ContentType.
type UpdateDatabaseJSONRequestBody = UpdateDatabaseBody

// CreatePermissionsGroupJSONRequestBody defines body for CreatePermissionsGroup for application/json ContentType.
type CreatePermissionsGroupJSONRequestBody = CreatePermissionsGroupBody

// UpdatePermissionsGroupJSONRequestBody defines body for UpdatePermissionsGroup for application/json ContentType.
type UpdatePermissionsGroupJSONRequestBody = UpdatePermissionsGroupBody

// CreateSessionJSONRequestBody defines body for CreateSession for application/json ContentType.
type CreateSessionJSONRequestBody = CreateSessionBody

// AsCollectionId0 returns the union data inside the Collection_Id as a CollectionId0
func (t Collection_Id) AsCollectionId0() (CollectionId0, error) {
	var body CollectionId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCollectionId0 overwrites any union data inside the Collection_Id as the provided CollectionId0
func (t *Collection_Id) FromCollectionId0(v CollectionId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCollectionId0 performs a merge with any union data inside the Collection_Id, using the provided CollectionId0
func (t *Collection_Id) MergeCollectionId0(v CollectionId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

// AsCollectionId1 returns the union data inside the Collection_Id as a CollectionId1
func (t Collection_Id) AsCollectionId1() (CollectionId1, error) {
	var body CollectionId1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCollectionId1 overwrites any union data inside the Collection_Id as the provided CollectionId1
func (t *Collection_Id) FromCollectionId1(v CollectionId1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCollectionId1 performs a merge with any union data inside the Collection_Id, using the provided CollectionId1
func (t *Collection_Id) MergeCollectionId1(v CollectionId1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(b, t.union)
	t.union = merged
	return err
}

func (t Collection_Id) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Collection_Id) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CreateCollection request with any body
	CreateCollectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCollection(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollection request
	GetCollection(ctx context.Context, collectionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCollection request with any body
	UpdateCollectionWithBody(ctx context.Context, collectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCollection(ctx context.Context, collectionId string, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatabase request with any body
	CreateDatabaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatabase(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDatabase request
	DeleteDatabase(ctx context.Context, databaseId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatabase request
	GetDatabase(ctx context.Context, databaseId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDatabase request with any body
	UpdateDatabaseWithBody(ctx context.Context, databaseId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDatabase(ctx context.Context, databaseId int, body UpdateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePermissionsGroup request with any body
	CreatePermissionsGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePermissionsGroup(ctx context.Context, body CreatePermissionsGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePermissionsGroup request
	DeletePermissionsGroup(ctx context.Context, groupId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissionsGroup request
	GetPermissionsGroup(ctx context.Context, groupId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePermissionsGroup request with any body
	UpdatePermissionsGroupWithBody(ctx context.Context, groupId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePermissionsGroup(ctx context.Context, groupId int, body UpdatePermissionsGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSession request with any body
	CreateSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSession(ctx context.Context, body CreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListTables request
	ListTables(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTableMetadata request
	GetTableMetadata(ctx context.Context, tableId int, params *GetTableMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CreateCollectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCollectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCollection(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCollectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollection(ctx context.Context, collectionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionRequest(c.Server, collectionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCollectionWithBody(ctx context.Context, collectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCollectionRequestWithBody(c.Server, collectionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCollection(ctx context.Context, collectionId string, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCollectionRequest(c.Server, collectionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabaseWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatabase(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatabaseRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDatabase(ctx context.Context, databaseId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDatabaseRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatabase(ctx context.Context, databaseId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatabaseRequest(c.Server, databaseId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatabaseWithBody(ctx context.Context, databaseId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatabaseRequestWithBody(c.Server, databaseId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatabase(ctx context.Context, databaseId int, body UpdateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatabaseRequest(c.Server, databaseId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePermissionsGroupWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePermissionsGroupRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePermissionsGroup(ctx context.Context, body CreatePermissionsGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePermissionsGroupRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePermissionsGroup(ctx context.Context, groupId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePermissionsGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissionsGroup(ctx context.Context, groupId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionsGroupRequest(c.Server, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePermissionsGroupWithBody(ctx context.Context, groupId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePermissionsGroupRequestWithBody(c.Server, groupId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePermissionsGroup(ctx context.Context, groupId int, body UpdatePermissionsGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePermissionsGroupRequest(c.Server, groupId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSessionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSessionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSession(ctx context.Context, body CreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSessionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListTables(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListTablesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTableMetadata(ctx context.Context, tableId int, params *GetTableMetadataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTableMetadataRequest(c.Server, tableId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateCollectionRequest calls the generic CreateCollection builder with application/json body
func NewCreateCollectionRequest(server string, body CreateCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCollectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCollectionRequestWithBody generates requests for CreateCollection with any type of body
func NewCreateCollectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collection")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCollectionRequest generates requests for GetCollection
func NewGetCollectionRequest(server string, collectionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionId", runtime.ParamLocationPath, collectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collection/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCollectionRequest calls the generic UpdateCollection builder with application/json body
func NewUpdateCollectionRequest(server string, collectionId string, body UpdateCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCollectionRequestWithBody(server, collectionId, "application/json", bodyReader)
}

// NewUpdateCollectionRequestWithBody generates requests for UpdateCollection with any type of body
func NewUpdateCollectionRequestWithBody(server string, collectionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionId", runtime.ParamLocationPath, collectionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collection/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateDatabaseRequest calls the generic CreateDatabase builder with application/json body
func NewCreateDatabaseRequest(server string, body CreateDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatabaseRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateDatabaseRequestWithBody generates requests for CreateDatabase with any type of body
func NewCreateDatabaseRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/database")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDatabaseRequest generates requests for DeleteDatabase
func NewDeleteDatabaseRequest(server string, databaseId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/database/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatabaseRequest generates requests for GetDatabase
func NewGetDatabaseRequest(server string, databaseId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/database/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDatabaseRequest calls the generic UpdateDatabase builder with application/json body
func NewUpdateDatabaseRequest(server string, databaseId int, body UpdateDatabaseJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDatabaseRequestWithBody(server, databaseId, "application/json", bodyReader)
}

// NewUpdateDatabaseRequestWithBody generates requests for UpdateDatabase with any type of body
func NewUpdateDatabaseRequestWithBody(server string, databaseId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "databaseId", runtime.ParamLocationPath, databaseId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/database/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreatePermissionsGroupRequest calls the generic CreatePermissionsGroup builder with application/json body
func NewCreatePermissionsGroupRequest(server string, body CreatePermissionsGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePermissionsGroupRequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePermissionsGroupRequestWithBody generates requests for CreatePermissionsGroup with any type of body
func NewCreatePermissionsGroupRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/permissions/group")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePermissionsGroupRequest generates requests for DeletePermissionsGroup
func NewDeletePermissionsGroupRequest(server string, groupId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/permissions/group/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPermissionsGroupRequest generates requests for GetPermissionsGroup
func NewGetPermissionsGroupRequest(server string, groupId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/permissions/group/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePermissionsGroupRequest calls the generic UpdatePermissionsGroup builder with application/json body
func NewUpdatePermissionsGroupRequest(server string, groupId int, body UpdatePermissionsGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePermissionsGroupRequestWithBody(server, groupId, "application/json", bodyReader)
}

// NewUpdatePermissionsGroupRequestWithBody generates requests for UpdatePermissionsGroup with any type of body
func NewUpdatePermissionsGroupRequestWithBody(server string, groupId int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/permissions/group/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateSessionRequest calls the generic CreateSession builder with application/json body
func NewCreateSessionRequest(server string, body CreateSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSessionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSessionRequestWithBody generates requests for CreateSession with any type of body
func NewCreateSessionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/session")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListTablesRequest generates requests for ListTables
func NewListTablesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/table")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTableMetadataRequest generates requests for GetTableMetadata
func NewGetTableMetadataRequest(server string, tableId int, params *GetTableMetadataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "tableId", runtime.ParamLocationPath, tableId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/table/%s/query_metadata", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.IncludeHiddenFields != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_hidden_fields", runtime.ParamLocationQuery, *params.IncludeHiddenFields); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateCollection request with any body
	CreateCollectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error)

	CreateCollectionWithResponse(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error)

	// GetCollection request
	GetCollectionWithResponse(ctx context.Context, collectionId string, reqEditors ...RequestEditorFn) (*GetCollectionResponse, error)

	// UpdateCollection request with any body
	UpdateCollectionWithBodyWithResponse(ctx context.Context, collectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error)

	UpdateCollectionWithResponse(ctx context.Context, collectionId string, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error)

	// CreateDatabase request with any body
	CreateDatabaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error)

	CreateDatabaseWithResponse(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error)

	// DeleteDatabase request
	DeleteDatabaseWithResponse(ctx context.Context, databaseId int, reqEditors ...RequestEditorFn) (*DeleteDatabaseResponse, error)

	// GetDatabase request
	GetDatabaseWithResponse(ctx context.Context, databaseId int, reqEditors ...RequestEditorFn) (*GetDatabaseResponse, error)

	// UpdateDatabase request with any body
	UpdateDatabaseWithBodyWithResponse(ctx context.Context, databaseId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatabaseResponse, error)

	UpdateDatabaseWithResponse(ctx context.Context, databaseId int, body UpdateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatabaseResponse, error)

	// CreatePermissionsGroup request with any body
	CreatePermissionsGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePermissionsGroupResponse, error)

	CreatePermissionsGroupWithResponse(ctx context.Context, body CreatePermissionsGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePermissionsGroupResponse, error)

	// DeletePermissionsGroup request
	DeletePermissionsGroupWithResponse(ctx context.Context, groupId int, reqEditors ...RequestEditorFn) (*DeletePermissionsGroupResponse, error)

	// GetPermissionsGroup request
	GetPermissionsGroupWithResponse(ctx context.Context, groupId int, reqEditors ...RequestEditorFn) (*GetPermissionsGroupResponse, error)

	// UpdatePermissionsGroup request with any body
	UpdatePermissionsGroupWithBodyWithResponse(ctx context.Context, groupId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePermissionsGroupResponse, error)

	UpdatePermissionsGroupWithResponse(ctx context.Context, groupId int, body UpdatePermissionsGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePermissionsGroupResponse, error)

	// CreateSession request with any body
	CreateSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSessionResponse, error)

	CreateSessionWithResponse(ctx context.Context, body CreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSessionResponse, error)

	// ListTables request
	ListTablesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTablesResponse, error)

	// GetTableMetadata request
	GetTableMetadataWithResponse(ctx context.Context, tableId int, params *GetTableMetadataParams, reqEditors ...RequestEditorFn) (*GetTableMetadataResponse, error)
}

type CreateCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Collection
}

// Status returns HTTPResponse.Status
func (r CreateCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Collection
}

// Status returns HTTPResponse.Status
func (r GetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Collection
}

// Status returns HTTPResponse.Status
func (r UpdateCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Database
}

// Status returns HTTPResponse.Status
func (r CreateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Database
}

// Status returns HTTPResponse.Status
func (r GetDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDatabaseResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Database
}

// Status returns HTTPResponse.Status
func (r UpdateDatabaseResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDatabaseResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePermissionsGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermissionsGroup
}

// Status returns HTTPResponse.Status
func (r CreatePermissionsGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePermissionsGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePermissionsGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeletePermissionsGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePermissionsGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionsGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermissionsGroup
}

// Status returns HTTPResponse.Status
func (r GetPermissionsGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionsGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePermissionsGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PermissionsGroup
}

// Status returns HTTPResponse.Status
func (r UpdatePermissionsGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePermissionsGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Session
}

// Status returns HTTPResponse.Status
func (r CreateSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListTablesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Table
}

// Status returns HTTPResponse.Status
func (r ListTablesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListTablesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTableMetadataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TableMetadata
}

// Status returns HTTPResponse.Status
func (r GetTableMetadataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTableMetadataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateCollectionWithBodyWithResponse request with arbitrary body returning *CreateCollectionResponse
func (c *ClientWithResponses) CreateCollectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error) {
	rsp, err := c.CreateCollectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCollectionResponse(rsp)
}

func (c *ClientWithResponses) CreateCollectionWithResponse(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error) {
	rsp, err := c.CreateCollection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCollectionResponse(rsp)
}

// GetCollectionWithResponse request returning *GetCollectionResponse
func (c *ClientWithResponses) GetCollectionWithResponse(ctx context.Context, collectionId string, reqEditors ...RequestEditorFn) (*GetCollectionResponse, error) {
	rsp, err := c.GetCollection(ctx, collectionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionResponse(rsp)
}

// UpdateCollectionWithBodyWithResponse request with arbitrary body returning *UpdateCollectionResponse
func (c *ClientWithResponses) UpdateCollectionWithBodyWithResponse(ctx context.Context, collectionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error) {
	rsp, err := c.UpdateCollectionWithBody(ctx, collectionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCollectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateCollectionWithResponse(ctx context.Context, collectionId string, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error) {
	rsp, err := c.UpdateCollection(ctx, collectionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCollectionResponse(rsp)
}

// CreateDatabaseWithBodyWithResponse request with arbitrary body returning *CreateDatabaseResponse
func (c *ClientWithResponses) CreateDatabaseWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.CreateDatabaseWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseResponse(rsp)
}

func (c *ClientWithResponses) CreateDatabaseWithResponse(ctx context.Context, body CreateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatabaseResponse, error) {
	rsp, err := c.CreateDatabase(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatabaseResponse(rsp)
}

// DeleteDatabaseWithResponse request returning *DeleteDatabaseResponse
func (c *ClientWithResponses) DeleteDatabaseWithResponse(ctx context.Context, databaseId int, reqEditors ...RequestEditorFn) (*DeleteDatabaseResponse, error) {
	rsp, err := c.DeleteDatabase(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDatabaseResponse(rsp)
}

// GetDatabaseWithResponse request returning *GetDatabaseResponse
func (c *ClientWithResponses) GetDatabaseWithResponse(ctx context.Context, databaseId int, reqEditors ...RequestEditorFn) (*GetDatabaseResponse, error) {
	rsp, err := c.GetDatabase(ctx, databaseId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatabaseResponse(rsp)
}

// UpdateDatabaseWithBodyWithResponse request with arbitrary body returning *UpdateDatabaseResponse
func (c *ClientWithResponses) UpdateDatabaseWithBodyWithResponse(ctx context.Context, databaseId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatabaseResponse, error) {
	rsp, err := c.UpdateDatabaseWithBody(ctx, databaseId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatabaseResponse(rsp)
}

func (c *ClientWithResponses) UpdateDatabaseWithResponse(ctx context.Context, databaseId int, body UpdateDatabaseJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatabaseResponse, error) {
	rsp, err := c.UpdateDatabase(ctx, databaseId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatabaseResponse(rsp)
}

// CreatePermissionsGroupWithBodyWithResponse request with arbitrary body returning *CreatePermissionsGroupResponse
func (c *ClientWithResponses) CreatePermissionsGroupWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePermissionsGroupResponse, error) {
	rsp, err := c.CreatePermissionsGroupWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePermissionsGroupResponse(rsp)
}

func (c *ClientWithResponses) CreatePermissionsGroupWithResponse(ctx context.Context, body CreatePermissionsGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePermissionsGroupResponse, error) {
	rsp, err := c.CreatePermissionsGroup(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePermissionsGroupResponse(rsp)
}

// DeletePermissionsGroupWithResponse request returning *DeletePermissionsGroupResponse
func (c *ClientWithResponses) DeletePermissionsGroupWithResponse(ctx context.Context, groupId int, reqEditors ...RequestEditorFn) (*DeletePermissionsGroupResponse, error) {
	rsp, err := c.DeletePermissionsGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePermissionsGroupResponse(rsp)
}

// GetPermissionsGroupWithResponse request returning *GetPermissionsGroupResponse
func (c *ClientWithResponses) GetPermissionsGroupWithResponse(ctx context.Context, groupId int, reqEditors ...RequestEditorFn) (*GetPermissionsGroupResponse, error) {
	rsp, err := c.GetPermissionsGroup(ctx, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionsGroupResponse(rsp)
}

// UpdatePermissionsGroupWithBodyWithResponse request with arbitrary body returning *UpdatePermissionsGroupResponse
func (c *ClientWithResponses) UpdatePermissionsGroupWithBodyWithResponse(ctx context.Context, groupId int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePermissionsGroupResponse, error) {
	rsp, err := c.UpdatePermissionsGroupWithBody(ctx, groupId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePermissionsGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdatePermissionsGroupWithResponse(ctx context.Context, groupId int, body UpdatePermissionsGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePermissionsGroupResponse, error) {
	rsp, err := c.UpdatePermissionsGroup(ctx, groupId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePermissionsGroupResponse(rsp)
}

// CreateSessionWithBodyWithResponse request with arbitrary body returning *CreateSessionResponse
func (c *ClientWithResponses) CreateSessionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSessionResponse, error) {
	rsp, err := c.CreateSessionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSessionResponse(rsp)
}

func (c *ClientWithResponses) CreateSessionWithResponse(ctx context.Context, body CreateSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSessionResponse, error) {
	rsp, err := c.CreateSession(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSessionResponse(rsp)
}

// ListTablesWithResponse request returning *ListTablesResponse
func (c *ClientWithResponses) ListTablesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListTablesResponse, error) {
	rsp, err := c.ListTables(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListTablesResponse(rsp)
}

// GetTableMetadataWithResponse request returning *GetTableMetadataResponse
func (c *ClientWithResponses) GetTableMetadataWithResponse(ctx context.Context, tableId int, params *GetTableMetadataParams, reqEditors ...RequestEditorFn) (*GetTableMetadataResponse, error) {
	rsp, err := c.GetTableMetadata(ctx, tableId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTableMetadataResponse(rsp)
}

// ParseCreateCollectionResponse parses an HTTP response from a CreateCollectionWithResponse call
func ParseCreateCollectionResponse(rsp *http.Response) (*CreateCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Collection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCollectionResponse parses an HTTP response from a GetCollectionWithResponse call
func ParseGetCollectionResponse(rsp *http.Response) (*GetCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Collection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCollectionResponse parses an HTTP response from a UpdateCollectionWithResponse call
func ParseUpdateCollectionResponse(rsp *http.Response) (*UpdateCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Collection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateDatabaseResponse parses an HTTP response from a CreateDatabaseWithResponse call
func ParseCreateDatabaseResponse(rsp *http.Response) (*CreateDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteDatabaseResponse parses an HTTP response from a DeleteDatabaseWithResponse call
func ParseDeleteDatabaseResponse(rsp *http.Response) (*DeleteDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDatabaseResponse parses an HTTP response from a GetDatabaseWithResponse call
func ParseGetDatabaseResponse(rsp *http.Response) (*GetDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateDatabaseResponse parses an HTTP response from a UpdateDatabaseWithResponse call
func ParseUpdateDatabaseResponse(rsp *http.Response) (*UpdateDatabaseResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDatabaseResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Database
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreatePermissionsGroupResponse parses an HTTP response from a CreatePermissionsGroupWithResponse call
func ParseCreatePermissionsGroupResponse(rsp *http.Response) (*CreatePermissionsGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePermissionsGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermissionsGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePermissionsGroupResponse parses an HTTP response from a DeletePermissionsGroupWithResponse call
func ParseDeletePermissionsGroupResponse(rsp *http.Response) (*DeletePermissionsGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePermissionsGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPermissionsGroupResponse parses an HTTP response from a GetPermissionsGroupWithResponse call
func ParseGetPermissionsGroupResponse(rsp *http.Response) (*GetPermissionsGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionsGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermissionsGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdatePermissionsGroupResponse parses an HTTP response from a UpdatePermissionsGroupWithResponse call
func ParseUpdatePermissionsGroupResponse(rsp *http.Response) (*UpdatePermissionsGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePermissionsGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PermissionsGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSessionResponse parses an HTTP response from a CreateSessionWithResponse call
func ParseCreateSessionResponse(rsp *http.Response) (*CreateSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Session
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListTablesResponse parses an HTTP response from a ListTablesWithResponse call
func ParseListTablesResponse(rsp *http.Response) (*ListTablesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListTablesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Table
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTableMetadataResponse parses an HTTP response from a GetTableMetadataWithResponse call
func ParseGetTableMetadataResponse(rsp *http.Response) (*GetTableMetadataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTableMetadataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TableMetadata
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
